#!/usr/bin/env bash
#
# Options
#
# --no-composer
# --no-version-check
# --no-mode
# --no-compile
# --no-static
# --no-db
# --no-launch
# --develop

if _flag_exists "--dry-run"; then
    FLAGS+=('--no-db')
    FLAGS+=('--no-launch')
fi

source "${PATH_DEPLOY}/router/verify-shared"

_do_title "Creating release in ${TSTAMP}"

[ -d "${PATH_RELEASE_NEW}" ] || mkdir "${PATH_RELEASE_NEW}"

cd "${PATH_RELEASE_NEW}"

# GIT
_do_title "Cloning Repository"
_do_titled_point " Repository:" "${REPO_URL}"
_do_line_break

if [ -z "${TSTAMP_DEBUG}" ]; then
    git clone --depth=1 "${REPO_URL}" . || _do_error "GIT"
else
    _do_point "Skipping as TSTAMP_DEBUG is set"
fi

# Shared Files
_do_title "Shared Files"

for SHARED_FILE in "${SHARED_FILES[@]}"; do
    SHARED_SOURCE_FILE_PREFIX="../../"
    SHARED_SOURCE_FILE="${SHARED_SOURCE_FILE_PREFIX}shared/${SHARED_FILE}"
    SHARED_TARGET_FILE="${PATH_RELEASE_NEW}/${SHARED_FILE}"
    SHARED_TARGET_FILE_PARENT_DIR=`dirname "${SHARED_TARGET_FILE}"`
    SHARED_FILE_SLASH_COUNT=$(printf '%s' "$SHARED_FILE" | tr -cd '/' | wc -c | tr -d ' ')
    
    if [ ! -d "${SHARED_TARGET_FILE_PARENT_DIR}" ]; then
        mkdir -p "${SHARED_TARGET_FILE_PARENT_DIR}"

        if [ ! -d "${SHARED_TARGET_FILE_PARENT_DIR}" ]; then
            _do_error "Could not create shared file parent directory at ${SHARED_TARGET_FILE_PARENT_DIR}"
        fi
    fi

    i=0
    while [ "$i" -lt "$SHARED_FILE_SLASH_COUNT" ]; do
        SHARED_SOURCE_FILE_PREFIX="${SHARED_SOURCE_FILE_PREFIX}../"
        i=$((i + 1))
    done
    
    SHARED_SOURCE_FILE_RELATIVE="${SHARED_SOURCE_FILE_PREFIX}shared/${SHARED_FILE}"

    _do_titled_point "Source:" "$(realpath ${SHARED_SOURCE_FILE})"
    _do_titled_point "Target:" "${PATH_RELEASE_NEW}/${SHARED_SOURCE_FILE_RELATIVE}"
    _do_line_break
    
    ln -s "${SHARED_SOURCE_FILE_RELATIVE}" "${SHARED_FILE}"
done

# Composer
_do_title "Installing dependencies via Composer"

if [ -z "${TSTAMP_DEBUG}" ]; then
    if _flag_exists "--no-composer"; then
        _do_skip_flag
    else
        composer install --no-dev || _do_error "Composer"
    fi
else
    _do_point "Skipping as TSTAMP_DEBUG is set"
fi

# Magento Version Check
_do_title "Magento Version"

if _flag_exists "--no-version-check"; then
    _do_skip_flag
else
    bin_magento "" || _do_error "Bin/Magento"
    _do_line_break
    bin_magento --version || _do_error "Version"
    _do_line_break
fi

# Mage Mode
_do_title "Magento Mode"

if _flag_exists "--no-mode"; then
    _do_skip_flag
else
    _do_point "MAGE_MODE=${MAGE_MODE}"
    _do_line_break
    bin_magento deploy:mode:set --skip-compilation "${MAGE_MODE}" || _do_error "MAGE_MODE"
fi

# Compile
_do_title "Compiling Magento"

if _flag_exists "--no-compile"; then
    _do_skip_flag
else
    _do_line_break
    bin_magento setup:di:compile || _do_error "Compile"
fi

# Static Assets
_do_title "Compiling Static Assets"

if _flag_exists "--no-static" || [ "${IS_DEV_MODE}" = 1 ]; then
    _do_skip_flag
else
    _deploy_static_assets || _do_error "Static Content"
fi

# Upgrade DB
_do_title "Upgrading the Database"

if _flag_exists "--no-db"; then
    _do_skip_flag
else
    _do_point "First enabling maintenance mode on the live site"

    if [ -d "${PATH_RELEASE_NEW}" ]; then
        (cd "${PATH_CURRENT}" && (bin_magento maintenance:enable) && cd -) \
            || _do_error "Maintenance on live"
    else
        _do_point "Skipping as live site does not exist"
    fi

    _do_point "Now upgrading the database"
    _do_line_break

    bin_magento setup:upgrade --keep-generated || _do_error "Upgrade DB. Live site may be down now due to maintenance mode."
fi

cd "${PATH_BASE}"

# Symlink
_do_title "Launch Site (Change Symlink)"

CURRENT_RESOLVED=$(readlink "${PATH_CURRENT}")
CURRENT_TARGET="./releases/${TSTAMP}"
_do_titled_point " Pre-Deploy:" "${CURRENT_RESOLVED}"
_do_titled_point "Post-Deploy:" "${CURRENT_TARGET}"

if _flag_exists "--no-launch"; then
    _do_line_break
    _do_skip_flag
    _do_line_break
else
    [ -L "${PATH_CURRENT}" ] && rm "${PATH_CURRENT}"

    ln -s "${CURRENT_TARGET}" current

    source "${PATH_DEPLOY}/router/reload"
fi

NEW_CURRENT_RESOLVED=$(readlink "${PATH_CURRENT}")
_do_titled_point "     Actual:" "${NEW_CURRENT_RESOLVED}"
_do_line_break
